#include "iarduino_I2C_Address.h"																								//
																																//
#define	DEF_CHIP_ID_FLASH	0x3C																								//	ID линейки чипов - константа для всех чипов серии Flash (позволяет идентифицировать принадлежность чипа к серии).
#define	DEF_CHIP_ID_METRO	0xC3																								//	ID линейки чипов - константа для всех чипов серии Metro (позволяет идентифицировать принадлежность чипа к серии).
//		Адреса регистров модуля:																								//
#define	REG_FLAGS_0			0x00																								//	Адрес регистра флагов управления для чтения.
#define	REG_BITS_0			0x01																								//	Адрес регистра битов  управления для чтения и записи.
#define	REG_FLAGS_1			0x02																								//	Адрес регистра флагов управления для чтения.
#define	REG_BITS_1			0x03																								//	Адрес регистра битов  управления для чтения и записи.
#define	REG_MODEL			0x04																								//	Адрес регистра содержащего номер типа модуля или очередной символ из названия модуля.
#define	REG_VERSION			0x05																								//	Адрес регистра содержащего версию прошивки.
#define	REG_ADDRESS			0x06																								//	Адрес регистра содержащего текущий адрес модуля на шине I2C. Если адрес указан с флагом IF-PIN-ADDRES то адрес установится (и запишется в регистр) только при наличии 1 на входе PIN_ADDRES.
#define	REG_CHIP_ID			0x07																								//	Адрес регистра содержащего ID линейки чипов «Flash». По данному ID можно определить принадлежность чипа к линейки «Flash».
#define REG_RANDOM_NUM		0x64																								//  Адрес регистра чтения случайного числа (младший байт). Значение занимает 2 байта. После чтения регистра, модуль в течении 5 мс будет отказывать мастеру в приёме номера регистра.
#define REG_RANDOM_ADR		0x66																								//  Адрес регистра смены адреса на 50 мс (0x0F), или подтверждения смены адреса (0xF0), или проверки смены адреса (Чтение).
#define REG_BUN_ADR			0x67																								//  Адрес регистра запрещённых адресов (первый регистр). Всего 15 регистров по 8 бит = 120 бит: REG_BUN_ADR[0]={0F-08}, ... , REG_BUN_ADR[14]={7F-78}.
//		Позиция битов и флагов в регистрах:																						//
#define	FLG_RESET			0x80																								//	Позиция флага в регистре «REG_FLAGS_0» информирующего о выполнении перезагрузки (0-нет, 1-выполнена). Флаг сбрасывается аппаратно, сразу после чтения регистра «REG_FLAGS_0».
#define	SET_RESET			0x80																								//	Позиция бита  в регистре «REG_BITS_0»  указывающего выполнить перезагрузку. Все регистры (и данный бит) сбросятся в значение по умолчанию.
#define	FLG_SELF_TEST		0x40																								//	Позиция флага в регистре «REG_FLAGS_0» информирующего о результате выполнения самотестирования (0-провал, 1-успех).
#define	SET_SELF_TEST		0x40																								//	Позиция бита  в регистре «REG_BITS_0»  указывающего выполнить самотестирование. Бит сомостоятельно сбросится по окончании самотестирования.
#define	FLG_GET_NAME		0x10																								//	Позиция флага в регистре «REG_FLAGS_0» информирующего о поддержке вывода названия модуля через регистр «REG_MODEL».
#define	BIT_GET_NAME		0x10																								//	Позиция бита  в регистре «REG_BITS_0»  указывающего выводить символы названия через регистр «REG_MODEL». Бит сбрасывается автоматически через 300мс после установки.
#define	FLG_RAND_ADR		0x08																								//	Позиция флага в регистре «REG_FLAGS_0» информирующего о возможности генерации случайного адреса для шины I2C.
#define	BIT_BLOCK_ADR		0x08																								//	Позиция бита  в регистре «REG_BITS_0»  указывающего о блокировке смены адреса. Бит устанавливается автоматически при попытке записи данных в регистры только для чтения или маской (BAN).
#define	FLG_I2C_UP			0x04																								//	Позиция флага в регистре «REG_FLAGS_0» информирующего о поддержке программной подтяжки линий шины I2C.
#define	SET_I2C_UP			0x04																								//	Позиция бита  в регистре «REG_BITS_0»  указывающего о состоянии программной подтяжки линий шины I2C (0-нет, 1-подтянуты).
#define	SAVE_ADR_EN			0x02																								//	Позиция бита  в регистре «REG_BITS_0»  разрешающего сохранение адреса в Flash память. Бит сбрасывается самостоятельно после записи адреса или при обращении к любому регистру кроме записи в «REG_BITS_0» и «ADDRESS».
#define	SAVE_FLASH			0x01																								//	Позиция бита  в регистре «REG_ADDRESS» указывающего что адрес требуется сохранить в Flash память. Если бит сброшен, то адрес «REG_ADDRESS» будет установлен временно (до отключения питания).
																																//	
//		Начало работы с модулем:																								//	Возвращаемое значение: результат обнаружения модуля.
bool	iarduino_I2C_Address::_begin			(void){																			//	Параметр: отсутствует
			valVers		= 0;																									//	Сбрасываем версию прошивки модуля.
			valModel	= 0;																									//	Сбрасываем номер модели модуля.
			valAddr		= 0;																									//	Сбрасываем подтверждённый адрес модуля.
			valDevice	= DEVICE_I2C_ABSENT;																					//	Указываем что модуль не найден (далее его проверим).
		//	Если адрес не указан, то ищим модуль на шине I2C:																	//
			if(valAddrTemp==0){																									//
				for(int i=1, j=0; i<127; i++){																					//	Проходим по всем адресам на шине I2C
					if( selI2C->checkAddress(i)	){ delay(2);																	//	Если на шине I2C есть устройство с адресом i ...
						if( valObjNum == j		){ valAddr=i; i=128; }else{ j++; }												//	Если номер объекта valObjNum совпадает с номером модуля j, считаем что модуль обнаружен, сохраняем значение i как найденный адрес и выходим из цикла, иначе увеличиваем номер модуля j и ищем дальше.
					}																											//
				}																												//
		//	Если адрес был указан, то сохраняем его.																			//
			}else{ valAddr=valAddrTemp; }																						//
		//	Если модуль не найден, то возвращаем ошибку:																		//
			if( valAddr == 0 ){ return false; }																					//
			if( selI2C->checkAddress(valAddr) == false	){ valAddr=0; return false; }											//	Если на шине I2C нет устройств с адресом valAddrTemp, то возвращаем ошибку.
		//	Проверяем модуль на принадлежность к линейке Flash I2C или Metro:													//
			valDevice = _checkDevice();																							//	
			if( valDevice==DEVICE_I2C_FLASH       ){																			//	Если модуль принадлежит линейке Flash I2C или Metro.
				if( _readBytes(REG_MODEL,2) ){																					//	Если удалось прочитать 2 байта в массив «data» из модуля начиная с регистра «REG_MODEL», то ...
					valModel = data[0];																							//	Сохраняем байт регистра «REG_MODEL»   (data[0]) в переменую «valModel».
					valVers  = data[1];																							//	Сохраняем байт регистра «REG_VERSION» (data[1]) в переменую «valVers».
				//	Перезагружаем модуль устанавливая его регистры в значение по умолчанию:										//
					delay(5);																									//
					reset();																									//	Выполняем программную перезагрузку.
				}																												//
			}																													//
			return true;																										//	Возвращаем флаг успешного обнаружения модуля.
}																																//
																																//
//		Перезагрузка модуля:																									//	Возвращаемое значение:	результат перезагрузки.
bool	iarduino_I2C_Address::reset				(void){																			//	Параметр:				отсутствует.
			if( valDevice==DEVICE_I2C_FLASH ){																					//	Если модуль принадлежит линейке Flash I2C или Metro, то ...
			//	Устанавливаем бит перезагрузки:																					//
				if( _readBytes (REG_BITS_0,1)==false		){return false;}													//	Читаем 1 байт регистра «REG_BITS_0» в массив «data».
				data[0] |= SET_RESET;																							//	Устанавливаем бит «SET_RESET»
				if( _writeBytes(REG_BITS_0,1)==false		){return false;}													//	Записываем 1 байт в регистр «REG_BITS_0» из массива «data».
			//	Переинициируем шину в связи с программным отключением подтяжек шины I2C в модуле:								//
				delay(10); selI2C->begin();																						//	Ждём восстановление подтяжек линий SCL/SDA и переинициируем работу с шиной I2C.
			//	Ждём установки флага завершения перезагрузки:																	//
				do{ if( _readBytes(REG_FLAGS_0,1)==false	){return false;} }													//	Читаем 1 байт регистра «REG_FLAGS_0» в массив «data».
				while( (data[0]&FLG_RESET) == 0);																				//	Повторяем чтение пока не установится флаг «FLG_RESET».
				return true;																									//
			}else{																												//	Иначе, если модуль не принадлежит линейке Flash I2C или Metro, то ...
				return false;																									//	Возвращаем ошибку.
			}																													//
}																																//
																																//
//		Смена адреса модуля:																									//	Возвращаемое значение:	резульат смены адреса.
bool	iarduino_I2C_Address::changeAddress	(uint8_t newAddr){																	//	Параметр:				newAddr - новый адрес модуля (0x07 < адрес < 0x7F).
			if( valDevice==DEVICE_I2C_FLASH ){																					//	Если модуль принадлежит линейке Flash I2C или Metro, то ...
			//	Проверяем новый адрес:																							//
				if( newAddr>0x7F ){ newAddr>>=1; }																				//	Корректируем адрес, если он указан с учётом бита RW.
				if( newAddr==0x00 || newAddr==0x7F	){return false;}															//	Запрещаем устанавливать адрес 0x00 и 0x7F.
			//	Записываем новый адрес:																							//
				if( _readBytes(REG_BITS_0,1)==false	){return false;}															//	Читаем 1 байт регистра «REG_BITS_0» в массив «data».
				data[0] &= ~BIT_BLOCK_ADR;																						//	Сбрасываем    бит «BIT_BLOCK_ADR».
				data[0] |=  SAVE_ADR_EN;																						//	Устанавливаем бит «SAVE_ADR_EN»
				if( _writeBytes(REG_BITS_0,1)==false	){return false;}														//	Записываем 1 байт в регистр «REG_BITS_0» из массива «data».
				data[0] = (newAddr<<1)|SAVE_FLASH;																				//	Готовим новый адрес к записи в модуль, установив бит «SAVE_FLASH».
				if( _writeBytes(REG_ADDRESS,1)==false){return false;}															//	Записываем 1 байт в регистр «ADDRESS» из массива «data».
				delay(200);																										//	Даём более чем достаточное время для применения модулем нового адреса.
			//	Проверяем наличие модуля с новым адресом на шине I2C:															//
				if( selI2C->checkAddress(newAddr)==false	){return false;}													//	Если на шине I2C нет модуля с адресом newAddr, то возвращаем ошибку.
				valAddrTemp = 0;																								//	Если адрес был указан в конструкторе, то стираем его.
				valAddr = newAddr;																								//	Сохраняем новый адрес как текущий.
				return true;																									//	Возвращаем флаг успеха.
			}else{																												//	Иначе, если модуль не принадлежит линейке Flash I2C или Metro, то ...
				return false;																									//	Возвращаем ошибку.
			}																													//
}																																//
																																//
//		Получение названия модуля:																								//	Возвращаемое значение:	строка String.
String	iarduino_I2C_Address::getName			(void){																			//	Параметр:				отсутствует.
			String str = "";																									//
			if( valDevice==DEVICE_I2C_FLASH ){																					//	Если модуль принадлежит линейке Flash I2C или Metro, то ...
			//	Считываем первые два регистра: регистр флагов и регистр битов:													//
				if( _readBytes(REG_FLAGS_0,2)==false ){ return str; }															//	Читаем 2 байта начиная с регистра «REG_FLAGS_0» в массив «data».
			//	Проверяем поддерживает ли модуль вывод своего названия:															//
				if( (data[0] & FLG_GET_NAME) == false ){ return str; }															//	Если флаг «FLG_GET_NAME» регистра «REG_FLAGS_0» сброшен, значит модуль не поддерживает вывод своего названия.
			//	Указываем модулю выводить своё название:																		//
				data[1] |= BIT_GET_NAME;																						//	Устанавливаем бит «BIT_GET_NAME» для регистра «REG_BITS_0».
				if( _writeBytes(REG_BITS_0,1,1)==false ){ return str; }															//	Записываем значение data[1] в регистр «REG_BITS_0».
			//	Читаем название модуля побайтно, но не дольше 300мс (иначе бит «BIT_GET_NAME» сбросится):						//
				uint8_t num=1;																									//	num - количество прочитанных символов.
				while( data[0] && num ){																						//	Если символ data[0] не является символом конца строки (0) и количество прочитанных символов < 256.
					_readBytes(REG_MODEL,1); if( data[0] ){ str+=(char)data[0]; } num++;										//	Читаем очередной символ из регистра «REG_MODEL» в data[0] и если data[0]>0 то сохраняем символ в «str».
				}																												//
			//	Сбрасываем бит указывающий выводить название модуля:                                             				//
				data[1] &= ~BIT_GET_NAME;																						//	Сбрасываем бит «BIT_GET_NAME» для регистра «REG_BITS_0».
				if( _writeBytes(REG_BITS_0,1,1)==false ){ delay(300); }															//	Записываем значение data[1] в регистр «REG_BITS_0». Если запись не удалась, то ждём 300мс, за это время бит сбросится сам.
			}																													//
			return str;																											//	Возвращаем строку.
}																																//
																																//
//		Получение флага наличия подтяжки линий шины I2C:																		//	Возвращаемое значение:	флаг наличия подтяжки линий шины I2C.
bool	iarduino_I2C_Address::getPullI2C		(void){																			//	Параметр:				отсутствует.
			if( valDevice==DEVICE_I2C_FLASH ){																					//	Если модуль принадлежит линейке Flash I2C или Metro, то ...
			//	Считываем первые два регистра: регистр флагов и регистр битов:													//
				if( _readBytes(REG_FLAGS_0,2)==false ){ return false; }															//	Читаем 2 байта начиная с регистра «REG_FLAGS_0» в массив «data».
			//	Проверяем поддерживает ли модуль управление подтяжкой линий шины I2C:											//
				if( (data[0] & FLG_I2C_UP) == false ){ return false; }															//	Если флаг «FLG_I2C_UP» регистра «REG_FLAGS_0» сброшен, значит модуль не поддерживает управление подтяжкой линий шины I2C.
			//	Проверяем установлена ли подтяжка линий шины I2C:																//
				if( (data[1] & SET_I2C_UP) == false ){ return false; }															//	Если бит  «SET_I2C_UP» регистра «REG_BITS_0»  сброшен, значит подтяжка линий шины I2C не установлена.
				return true;																									//	Возвращаем флаг успеха.
			}else{																												//	Иначе, если модуль не принадлежит линейке Flash I2C или Metro, то ...
				return false;																									//	Возвращаем ошибку.
			}																													//
}																																//
																																//
//		Установка подтяжки линий шины I2C:																						//	Возвращаемое значение:	результат установки подтяжки линий шины I2C.
bool	iarduino_I2C_Address::setPullI2C		(bool f){																		//	Параметр:				флаг подтяжки линий шины I2C.
			if( valDevice==DEVICE_I2C_FLASH ){																					//	Если модуль принадлежит линейке Flash I2C или Metro, то ...
			//	Считываем первые два регистра: регистр флагов и регистр битов:													//
				if( _readBytes(REG_FLAGS_0,2)==false ){ return false; }															//	Читаем 2 байта начиная с регистра «REG_FLAGS_0» в массив «data».
			//	Проверяем поддерживает ли модуль управление подтяжкой линий шины I2C:											//
				if( (data[0] & FLG_I2C_UP) == false ){ return false; }															//	Если флаг «FLG_I2C_UP» регистра «REG_FLAGS_0» сброшен, значит модуль не поддерживает управление подтяжкой линий шины I2C.
			//	Устанавливаем или сбрасываем бит включения подтяжки линий шины I2C:												//
				if(f){ data[0] = (data[1] |  SET_I2C_UP); }																		//	Если флаг «f» установлен, то копируем значение из 1 в 0 элемент массива «data» установив бит «SET_I2C_UP».
				else { data[0] = (data[1] & ~SET_I2C_UP); }																		//	Если флаг «f» сброшен   , то копируем значение из 1 в 0 элемент массива «data» сбросив   бит «SET_I2C_UP».
			//	Сохраняем получившееся значение в регистр «REG_BITS_0»:															//
				if( _writeBytes(REG_BITS_0,1)==false ){ return false; }															//	Записываем 1 байт в регистр «REG_BITS_0» из массива «data».
				delay(50);																										//	Даём время для сохранения данных в энергонезависимую память модуля.
				return true;																									//	Возвращаем флаг успеха.
			}else{																												//	Иначе, если модуль не принадлежит линейке Flash I2C или Metro, то ...
				return false;																									//	Возвращаем ошибку.
			}																													//
}																																//
																																//
//		Чтение данных из регистров в массив data:																				//	Возвращаемое значение:	результат чтения (true/false).
bool	iarduino_I2C_Address::_readBytes		(uint8_t reg, uint8_t sum){														//	Параметры:				reg - номер первого регистра, sum - количество читаемых байт.
			bool	result=false;																								//	Определяем флаг       для хранения результата чтения.
			uint8_t	sumtry=10;																									//	Определяем переменную для подсчёта количества оставшихся попыток чтения.
			do{	result = selI2C->readBytes(valAddr, reg, data, sum);															//	Считываем из модуля valAddr, начиная с регистра reg, в массив data, sum байт.
				sumtry--;	if(!result){delay(1);}																				//	Уменьшаем количество попыток чтения и устанавливаем задержку при неудаче.
			}	while		(!result && sumtry>0);																				//	Повторяем чтение если оно завершилось неудачей, но не более sumtry попыток.
			delayMicroseconds(500);																								//	Между пакетами необходимо выдерживать паузу.
			return result;																										//	Возвращаем результат чтения (true/false).
}																																//
																																//
//		Запись данных в регистры из массива data:																				//	Возвращаемое значение:	результат записи (true/false).
bool	iarduino_I2C_Address::_writeBytes	(uint8_t reg, uint8_t sum, uint8_t num){											//	Параметры:				reg - номер первого регистра, sum - количество записываемых байт, num - номер первого элемента массива data.
			bool	result=false;																								//	Определяем флаг       для хранения результата записи.
			uint8_t	sumtry=10;																									//	Определяем переменную для подсчёта количества оставшихся попыток записи.
			do{	result = selI2C->writeBytes(valAddr, reg, &data[num], sum);														//	Записываем в модуль valAddr начиная с регистра reg, sum байи из массива data начиная с элемента num.
				sumtry--;	if(!result){delay(1);}																				//	Уменьшаем количество попыток записи и устанавливаем задержку при неудаче.
			}	while		(!result && sumtry>0);																				//	Повторяем запись если она завершилась неудачей, но не более sumtry попыток.
			delay(5);																											//	Ждём применения модулем записанных данных.
			return result;																										//	Возвращаем результат записи (true/false).
}																																//
																																//
//		Определение типа устройства:																							//	Возвращаемое значение:	результат проверки (DEVICE_I2C_ABSENT / DEVICE_I2C_DOUBLE / DEVICE_I2C_UNKNOWN / DEVICE_I2C_FLASH).
uint8_t	iarduino_I2C_Address::_checkDevice	(void){																				//	Параметр:				отсутствует.
		//	Проверяем наличие модуля на шине:																					//
			if( selI2C->checkAddress(valAddr) == false ){ return DEVICE_I2C_ABSENT; }											//	Если на шине I2C нет устройств с адресом valAddr, то возвращаем ошибку.
		//	Проверяем модуль на принадлежность к линейке Flash I2C или Metro:													//
			if( _readBytes(REG_ADDRESS,2)									){													//	Если удалось прочитать 2 байта в массив «data» из модуля начиная с регистра «REG_ADDRESS», то ...
			if((data[0]>>1)==valAddr || data[0]==0xFF						){													//	Если значение регистра «REG_ADDRESS» (data[0]) совпадает с адресом модуля или совпадает со значением 0xFF, то ...
			if( data[1]==DEF_CHIP_ID_FLASH  || data[1]==DEF_CHIP_ID_METRO	){ 													//	Если значение регистра «REG_CHIP_ID» (data[1]) совпадает со значением DEF_CHIP_ID_FLASH или DEF_CHIP_ID_METRO, то ...
			//	Если модуль поддерживает смену адреса на случайное число:														//	
				if( _readBytes(REG_FLAGS_0,1) ){																					//	Если удалось прочитать 1 байт в массив «data» из модуля начиная с регистра «REG_FLAGS_0», то ...
				if( data[0] & FLG_RAND_ADR   ){																					//	Если в регистре «REG_FLAGS_0» установлен флаг «FLG_RAND_ADR» значит модуль поддерживает смену адреса на случайное число.
				//	Проверяем наличие дублёров на одном адресе:																	//	
					for(uint8_t i=0; i<2; i++){																					//	Выполняем две попытки двойного чтения...
						delay(50);																								//	Готовимся к очередному чтению случайного числа.
						if(! selI2C->readBytes(valAddr, REG_RANDOM_NUM, data, 2) ){ return DEVICE_I2C_DOUBLE; }else{			//	Если не удалось прочитать случайное число с первого  раза, то подозреваем что ктото мешает на этом адресе. А если удалось, то модуль должен на 5 мс перестать принимать номера регистров от мастера.
						delayMicroseconds(500);																					//	Ждём 500мкс.
						if(  selI2C->readBytes(valAddr, REG_RANDOM_NUM, data, 2) ){ return DEVICE_I2C_DOUBLE; }    }			//	Если    удалось прочитать случайное число со второго раза, значит ответил второй модуль на этом адресе, т.к. после первого чтения модуль должен был молчать 5 мс.
					}	delay(50);																								//  Модуль должен начать принимать номера регистров от мастера через 5 мс после чтения регистра «REG_RANDOM_NUM».
						return DEVICE_I2C_FLASH;																				//	Модуль принадлежит линейке Flash I2C или Metro.
				}}		return DEVICE_I2C_FLASH_OLD;																			//	Модуль принадлежит линейке Flash I2C или Metro без поддержки вывода названия и автоматической смены адреса.
			}}}			return DEVICE_I2C_UNKNOWN;																				//	Модуль обнаружен но не опознан.
}																																//
																																//
//		Чтение, установка, сброс флагов адресов в массивы arrF, arrO, arrU, arrD:												//
bool	iarduino_I2C_SortAddress::_getBit(uint8_t* a, uint8_t b){ return a[b/8-1] & (1<<(b%8)); }								//	Прочитать из массива (a) бит соответствующий адресу (b).
void	iarduino_I2C_SortAddress::_setBit(uint8_t* a, uint8_t b){        a[b/8-1]|= (1<<(b%8)); }								//	Установить в массиве (a) бит соответствующий адресу (b).
void	iarduino_I2C_SortAddress::_delBit(uint8_t* a, uint8_t b){        a[b/8-1]&=~(1<<(b%8)); }								//	Сбросить   в массиве (a) бит соответствующий адресу (b).
uint8_t	iarduino_I2C_SortAddress::_getSum(uint8_t* a){uint8_t b, i=0; for(b=8; b<120; b++){ if(_getBit(a,b)){i++;}} return i; }	//  Вернуть количество всех установленных битов в массиве (a).
																																//
//		Заполнение массивов arrF, arrO, arrU и arrD:																			//	Возвращаемое значение:	отсутствует.
void	iarduino_I2C_SortAddress::_fillArray(void){																				//	Параметр:				отсутствует.
		//	Сбрасываем все флаги массивов arrF, arrO, arrU и arrD:																//
			for(uint8_t i=0; i<15; i++){ arrF[i]=0; arrO[i]=0; arrU[i]=0; arrD[i]=0; }											//
		//	Проходим по всем возможным адресам на шине:																			//
			for(valAddr=8; valAddr<127; valAddr++){																				//
			//  Проверяем очередное устройство:																					//
				switch( _checkDevice() ){																						//
					case DEVICE_I2C_FLASH:		_setBit(arrF, valAddr); break;													//	Найдено устройство из линейки Flash I2C или Metro.
					case DEVICE_I2C_FLASH_OLD:	_setBit(arrO, valAddr); break;													//	Найдено устройство из линейки Flash I2C или Metro без поддержки вывода названия и сортировки адреса.
					case DEVICE_I2C_UNKNOWN:	_setBit(arrU, valAddr); break;													//	Найдено неизвестное устройство.
					case DEVICE_I2C_DOUBLE:		_setBit(arrD, valAddr); break;													//	Найден  адрес принадлежащий двум и более модулям.
				}																												//
			}																													//
}																																//
																																//
//		Сортировка адресов:																										//	Возвращаемое значение:	флаг выполнения сортировки.
bool	iarduino_I2C_SortAddress::sorting(uint8_t start){																		//	Параметр:				Первый назначаемый адрес нового списка.
			bool	result=false;																								//	Флаг       для хранения флага изменения адреса.
			uint8_t	sumtry;																										//	Переменная для подсчёта количества оставшихся попыток.
		//	Заполняем массивы arrF, arrO, arrU и arrD:																			//
			_fillArray();																										//
		//	Если на шине есть дублёры (адреса занятые несколькими устройствами):												//
			sumtry=10;																											//
			while( _getSum(arrD) && sumtry>0 ){																					//	Выполняем цикл пока есть дублёры в массиве arrD, но не более sumtry попыток.
				sumtry--;																										//
			//	Избавляемся от дублёров в массиве arrD:																			//
				for(uint8_t i=8; i<127; i++){																					//
				//	Если адрес i имеется в массиве arrD:																		//
					if( _getBit(arrD, i) ){																						//
						_delBit(arrD, i);																						//	Удаляем адрес i из массива arrD.
						valAddr=i;																								//
					//	Отправляем всем устройствам с адресом i, список запрещённых адресов:									//
						for(uint8_t j=0; j<15; j++){ data[j]=arrF[j]|arrO[j]|arrU[j]|arrD[j]; }									//	Заполняем массив data битами запрещённых адресов.
						if( _writeBytes(REG_BUN_ADR, 15) ){																		//	Отправляем 15 байт данных в регистр REG_BUN_ADR.
						//	Указывем всем устройствам с адресом i, сменить его на случайное число:								//
							data[0]=0x0F;																						//
							if( _writeBytes(REG_RANDOM_ADR, 1) ){																//	Отправляем 1 байт (0x0F) в регистр REG_RANDOM_ADR.
//								delay(10);																						//
							//	Находим вновь созданные адреса:																	//
								for(valAddr=8; valAddr<127; valAddr++){															//
								//	Если адрес valAddr отсутствует в массивах arrF, arrO, arrU и arrD:							//
									if( !_getBit(arrF,valAddr) && !_getBit(arrO,valAddr) && !_getBit(arrU,valAddr) && !_getBit(arrD,valAddr) ){
									//	Если устройство с адресом valAddr присутствует на шине:									//
										if( selI2C->checkAddress(valAddr) ){													//
										//	Убеждаемся что адрес valAddr является временным (действует 50мс):					//
											if( _readBytes(REG_RANDOM_ADR, 1) ){												//	Читаем 1 байт из регистра REG_RANDOM_ADR
											//	Возможные значения при чтении: 0x00, 0x55, 0xFF									//	0x00 - новый адрес не подтверждён и отменён, 0x55 - действует новый адрес на 50мс, 0xFF - новый адрес подтверждён и действует до отключения питания.
												if( data[0]==0x55 ){															//
												//	Указываем модулю сохранить временный адрес до откл. питания:				//
													data[0]=0xF0;																//
													if( _writeBytes(REG_RANDOM_ADR, 1) ){										//	Отправляем 1 байт (0xF0) в регистр REG_RANDOM_ADR.
													//	Сохраняем новый адрес в массив arrF:									//
														_setBit(arrF,valAddr);													//
													}																			//
												}																				//
											}																					//
										}																						//
									}																							//
								}																								//
							}																									//
						}																										//
					}																											//
				}																												//
			//	Даём время неопозднанным устройствам восстановить адрес:														//
				delay(50);																										//  Если временный адрес не подтвердить в REG_RANDOM_ADR то он отменится через 50мс.
			//	Заполняем массивы arrF, arrO, arrU и arrD:																		//
				_fillArray();																									//
			}																													//
		//	Выполняем сортировку адресов:																						//
			for(uint8_t i=start; i<127; i++){																					//  Проходим по назначаемым адресам.
			//	Если адрес i присутствует в любом из массивов arrF, arrO, arrU и arrD:											//
				if( _getBit(arrF,i) || _getBit(arrO,i) || _getBit(arrU,i) || _getBit(arrD,i) ){									//
				//	Если это устройство из линейки Flash I2C:																	//
					if( _getBit(arrF,i) ){																						//
					//	Если адрес устройства временный (назначен при избавлении от дублёров) действует до отключения питания:	//
						valAddr=i;																								//
						if( _readBytes(REG_RANDOM_ADR, 1) ){																	//
						//	Возможные значения при чтении: 0x00, 0x55, 0xFF														//	0x00 - новый адрес не подтверждён и отменён, 0x55 - действует новый адрес на 50мс, 0xFF - новый адрес подтверждён и действует до отключения питания.
							if( data[0]==0xFF ){																				//
							//	Стираем информацию о изменении адреса:															//
								data[0]=0x00;																					//
								if( _writeBytes(REG_RANDOM_ADR, 1) ){															//	Отправляем 1 байт (0x00) в регистр REG_RANDOM_ADR.
								//	Сохраняем адрес как постоянный:																//
									_changeAddress(valAddr);																	//
									result=true;																				//
								}																								//
							}																									//
						}																										//
					}																											//
				}else{																											//
				//	Если устройства с адресом i нет, то находим очередное устройство iArduino в массиве arrF:					//
					for(uint8_t j=8; j<127; j++){																				//
					//	Если устройство ещё не отсортировано:																	//
						if( j<start || j>i ){																					//	[8 ...] start [отсортированные] i [...] 127
						//	Если это устройство из линейки Flash I2C:															//
							if( _getBit(arrF,j) ){																				//
							//	Если адрес устройства временный (назначен при избавлении от дублёров):							//
								valAddr=j;																						//
								if( _readBytes(REG_RANDOM_ADR, 1) ){															//
								//	Возможные значения при чтении: 0x00, 0x55, 0xFF												//	0x00 - новый адрес не подтверждён и отменён, 0x55 - действует новый адрес на 50мс, 0xFF - новый адрес подтверждён и действует до отключения питания.
									if( data[0]==0xFF ){																		//
									//	Стираем информацию о изменении адреса:													//
										data[0]=0x00;																			//
										_writeBytes(REG_RANDOM_ADR, 1);															//	Отправляем 1 байт (0x00) в регистр REG_RANDOM_ADR.
									}																							//
								}																								//
							//	Меняем адрес устройства c j на i:																//
								_changeAddress(i);																				//
								_setBit(arrF,i);																				//
								_delBit(arrF,j);																				//
								result=true;																					//
							//	Выходим из цикла:																				//
								j=127;																							//
							}																									//
						}																										//
					}																											//
				}																												//
			}																													//
			return result;																										//
}																																//
																																//
//		Чтение данных из регистров в массив data:																				//	Возвращаемое значение:	результат чтения (true/false).
bool	iarduino_I2C_SortAddress::_readBytes		(uint8_t reg, uint8_t sum){													//	Параметры:				reg - номер первого регистра, sum - количество читаемых байт.
			bool	result=false;																								//	Определяем флаг       для хранения результата чтения.
			uint8_t	sumtry=10;																									//	Определяем переменную для подсчёта количества оставшихся попыток чтения.
			do{	result = selI2C->readBytes(valAddr, reg, data, sum);															//	Считываем из модуля valAddr, начиная с регистра reg, в массив data, sum байт.
				sumtry--;	if(!result){delay(1);}																				//	Уменьшаем количество попыток чтения и устанавливаем задержку при неудаче.
			}	while		(!result && sumtry>0);																				//	Повторяем чтение если оно завершилось неудачей, но не более sumtry попыток.
			delayMicroseconds(500);																								//	Между пакетами необходимо выдерживать паузу.
			return result;																										//	Возвращаем результат чтения (true/false).
}																																//
																																//
//		Запись данных в регистры из массива data:																				//	Возвращаемое значение:	результат записи (true/false).
bool	iarduino_I2C_SortAddress::_writeBytes	(uint8_t reg, uint8_t sum, uint8_t num){										//	Параметры:				reg - номер первого регистра, sum - количество записываемых байт, num - номер первого элемента массива data.
			bool	result=false;																								//	Определяем флаг       для хранения результата записи.
			uint8_t	sumtry=10;																									//	Определяем переменную для подсчёта количества оставшихся попыток записи.
			do{	result = selI2C->writeBytes(valAddr, reg, &data[num], sum);														//	Записываем в модуль valAddr начиная с регистра reg, sum байи из массива data начиная с элемента num.
				sumtry--;	if(!result){delay(1);}																				//	Уменьшаем количество попыток записи и устанавливаем задержку при неудаче.
			}	while		(!result && sumtry>0);																				//	Повторяем запись если она завершилась неудачей, но не более sumtry попыток.
			delay(5);																											//	Ждём применения модулем записанных данных.
			return result;																										//	Возвращаем результат записи (true/false).
}																																//
																																//
//		Определение типа устройства:																							//	Возвращаемое значение:	результат проверки (DEVICE_I2C_ABSENT / DEVICE_I2C_DOUBLE / DEVICE_I2C_UNKNOWN / DEVICE_I2C_FLASH).
uint8_t	iarduino_I2C_SortAddress::_checkDevice	(void){																			//	Параметр:				отсутствует.
		//	Проверяем наличие модуля на шине:																					//
			if( selI2C->checkAddress(valAddr) == false ){ return DEVICE_I2C_ABSENT; }											//	Если на шине I2C нет устройств с адресом valAddr, то возвращаем ошибку.
		//	Проверяем модуль на принадлежность к линейке Flash I2C или Metro:													//
			if( _readBytes(REG_ADDRESS,2)									){													//	Если удалось прочитать 2 байта в массив «data» из модуля начиная с регистра «REG_ADDRESS», то ...
			if((data[0]>>1)==valAddr || data[0]==0xFF						){													//	Если значение регистра «REG_ADDRESS» (data[0]) совпадает с адресом модуля или совпадает со значением 0xFF, то ...
			if( data[1]==DEF_CHIP_ID_FLASH  || data[1]==DEF_CHIP_ID_METRO	){ 													//	Если значение регистра «REG_CHIP_ID» (data[1]) совпадает со значением DEF_CHIP_ID_FLASH или DEF_CHIP_ID_METRO, то ...
			//	Если модуль поддерживает смену адреса на случайное число:														//	
				if( _readBytes(REG_FLAGS_0,1) ){																				//	Если удалось прочитать 1 байт в массив «data» из модуля начиная с регистра «REG_FLAGS_0», то ...
				if( data[0] & FLG_RAND_ADR    ){																				//	Если в регистре «REG_FLAGS_0» установлен флаг «FLG_RAND_ADR» значит модуль поддерживает смену адреса на случайное число.
				//	Проверяем наличие дублёров на одном адресе:																	//	
					for(uint8_t i=0; i<2; i++){																					//	Выполняем две попытки двойного чтения...
						delay(50);																								//	Готовимся к очередному чтению случайного числа.
						if(! selI2C->readBytes(valAddr, REG_RANDOM_NUM, data, 2) ){ return DEVICE_I2C_DOUBLE; }else{			//	Если не удалось прочитать случайное число с первого  раза, то подозреваем что ктото мешает на этом адресе. А если удалось, то модуль должен на 5 мс перестать принимать номера регистров от мастера.
						delayMicroseconds(500);																					//	Ждём 500мкс.
						if(  selI2C->readBytes(valAddr, REG_RANDOM_NUM, data, 2) ){ return DEVICE_I2C_DOUBLE; }    }			//	Если    удалось прочитать случайное число со второго раза, значит ответил второй модуль на этом адресе, т.к. после первого чтения модуль должен был молчать 5 мс.
					}	delay(50);																								//  Модуль должен начать принимать номера регистров от мастера через 5 мс после чтения регистра «REG_RANDOM_NUM».
						return DEVICE_I2C_FLASH;																				//	Модуль принадлежит линейке Flash I2C или Metro.
				}}		return DEVICE_I2C_FLASH_OLD;																			//	Модуль принадлежит линейке Flash I2C или Metro без поддержки вывода названия и автоматической смены адреса.
			}}}			return DEVICE_I2C_UNKNOWN;																				//	Модуль обнаружен но не опознан.
}																																//
																																//
//		Смена адреса модуля:																									//	Возвращаемое значение:	резульат смены адреса.
bool	iarduino_I2C_SortAddress::_changeAddress(uint8_t newAddr){																//	Параметр:				newAddr - новый адрес модуля (0x07 < адрес < 0x7F).
		//	Проверяем новый адрес:																								//
			if( newAddr>0x7F ){ newAddr>>=1; }																					//	Корректируем адрес, если он указан с учётом бита RW.
			if( newAddr==0x00 || newAddr==0x7F			){return false;}														//	Запрещаем устанавливать адрес 0x00 и 0x7F.
		//	Записываем новый адрес:																								//
			if( _readBytes(REG_BITS_0,1)==false			){return false;}														//	Читаем 1 байт регистра «REG_BITS_0» в массив «data».
			data[0] &= ~BIT_BLOCK_ADR;																							//	Сбрасываем    бит «BIT_BLOCK_ADR».
			data[0] |=  SAVE_ADR_EN;																							//	Устанавливаем бит «SAVE_ADR_EN»
			if( _writeBytes(REG_BITS_0,1)==false		){return false;}														//	Записываем 1 байт в регистр «REG_BITS_0» из массива «data».
			data[0] = (newAddr<<1)|SAVE_FLASH;																					//	Готовим новый адрес к записи в модуль, установив бит «SAVE_FLASH».
			if( _writeBytes(REG_ADDRESS,1)==false		){return false;}														//	Записываем 1 байт в регистр «ADDRESS» из массива «data».
			delay(200);																											//	Даём более чем достаточное время для применения модулем нового адреса.
		//	Проверяем наличие модуля с новым адресом на шине I2C:																//
			if( selI2C->checkAddress(newAddr)==false	){return false;}														//	Если на шине I2C нет модуля с адресом newAddr, то возвращаем ошибку.
			valAddr = newAddr;																									//	Сохраняем новый адрес как текущий.
			return true;																										//	Возвращаем флаг успеха.
}																																//
