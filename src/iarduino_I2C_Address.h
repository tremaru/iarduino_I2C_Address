//	Библиотека для работы с модулями серии I2C-flash для Arduino: https://iarduino.ru/search/?text=flash
//  Версия: 1.0.0
//  Последнюю версию библиотеки Вы можете скачать по ссылке: https://iarduino.ru/file/558.html
//  Подробное описание функций бибилиотеки доступно по ссылке: https://wiki.iarduino.ru/
//  Библиотека является собственностью интернет магазина iarduino.ru и может свободно использоваться и распространяться!
//  При публикации устройств или скетчей с использованием данной библиотеки, как целиком, так и её частей,
//  в том числе и в некоммерческих целях, просим Вас опубликовать ссылку: http://iarduino.ru
//  Автор библиотеки: Панькин Павел.
//  Если у Вас возникли технические вопросы, напишите нам: shop@iarduino.ru

#ifndef iarduino_I2C_Address_h																					//
#define iarduino_I2C_Address_h																					//
																												//
#if defined(ARDUINO) && (ARDUINO >= 100)																		//
#include		<Arduino.h>																						//
#else																											//
#include		<WProgram.h>																					//
#endif																											//
																												//
#include		<iarduino_I2C_Address_I2C.h>																	//	Подключаем файл iarduino_I2C_Address_I2C.h - для работы с шиной I2C		(используя функции структуры iI2C)
																												//
#define			DEF_CHIP_ID_FLASH		0x3C																	//	ID линейки чипов - константа для всех чипов серии Flash (позволяет идентифицировать принадлежность чипа к серии).
#define			DEF_CHIP_ID_METRO		0xC3																	//	ID линейки чипов - константа для всех чипов серии Metro (позволяет идентифицировать принадлежность чипа к серии).
//				Адреса регистров модуля:																		//
#define			REG_FLAGS_0				0x00																	//	Адрес регистра флагов управления для чтения.
#define			REG_BITS_0				0x01																	//	Адрес регистра битов  управления для чтения и записи.
#define			REG_FLAGS_1				0x02																	//	Адрес регистра флагов управления для чтения.
#define			REG_BITS_1				0x03																	//	Адрес регистра битов  управления для чтения и записи.
#define			REG_MODEL				0x04																	//	Адрес регистра содержащего номер типа модуля.
#define			REG_VERSION				0x05																	//	Адрес регистра содержащего версию прошивки.
#define			REG_ADDRESS				0x06																	//	Адрес регистра содержащего текущий адрес модуля на шине I2C. Если адрес указан с флагом IF-PIN-ADDRES то адрес установится (и запишется в регистр) только при наличии 1 на входе PIN_ADDRES.
#define			REG_CHIP_ID				0x07																	//	Адрес регистра содержащего ID линейки чипов «Flash». По данному ID можно определить принадлежность чипа к линейки «Flash».
																												//
class iarduino_I2C_Address{																						//
	public:																										//
	/**	Конструктор класса **/																					//
		iarduino_I2C_Address					(uint8_t address=0){											//	Конструктор класса														(Параметр: адрес модуля на шине I2C, если не указан (=0), то адрес будет определён).
													if(address>0x7F){ address>>=1; }							//	Корректируем адрес, если он указан с учётом бита RW.
							valAddrTemp			=	address;													//	Сохраняем переданный адрес модуля.
							objI2C				=	new iarduino_I2C;											//	Переопределяем указатель objI2C на объект производного класса iarduino_I2C.
			static uint8_t	objSum				=	0;															//	Определяем переменную для хранения количества созданных объектов класса.
							valObjNum			=	objSum++;													//	Определяем номер созданного объекта класса.
		}																										//
	/**	Пользовательские функции **/																			//
		bool				begin				(void				);											//	Объявляем  функцию инициализации модуля									(Параметр:  отсутствует).
		bool				reset				(void				);											//	Объявляем  функцию перезагрузки модуля									(Параметр:  отсутствует).
		bool				changeAddress		(uint8_t			);											//	Объявляем  функцию смены адреса модуля на шине I2C						(Параметр:  новый адрес модуля).
		uint8_t				getAddress			(void				){ return valAddr;				}			//	Определяем функцию возвращающую текущий адрес модуля на шине I2C		(Параметр:  отсутствует).
		uint8_t				getVersion			(void				){ return valVers;				}			//	Определяем функцию возвращающую текущую версию прошивки модуля			(Параметр:  отсутствует).
		uint8_t				getModel			(void				){ return valModel;				}			//	Определяем функцию возвращающую номер модели модуля						(Параметр:  отсутствует).
		bool				getPullI2C			(void				);											//	Объявляем  функцию возвращающую флаг наличия подтяжки шины I2C			(Параметр:  отсутствует).
		bool				setPullI2C			(bool=true			);											//	Объявляем  функцию установки    подтяжки шины I2C						(Параметр:  флаг подтяжки).
		bool				operator =			(uint8_t adr		){ return changeAddress(adr);	}			//	Определяем функцию смены адреса модуля на шине I2C						(Параметр:  новый адрес модуля).
							operator uint8_t	(					){ return getAddress();			}			//	Определяем функцию возвращающую текущий адрес модуля на шине I2C		(Параметр:  отсутствует).
	private:																									//
	/**	Внутренние переменные **/																				//
		uint8_t				valAddrTemp			=	0;															//	Определяем переменную для хранения адреса модуля на шине I2C который был указан, но не был проверен.
		uint8_t				valAddr				=	0;															//	Определяем переменную для хранения адреса модуля на шине I2C.
		uint8_t				valVers				=	0;															//	Определяем переменную для хранения версии прошивки модуля.
		uint8_t				valModel			=	0;															//	Определяем переменную для хранения номера модели модуля.
		uint8_t				valObjNum;																			//	Объявляем  переменную для хранения номера созданного объекта класса.
		uint8_t				data[4];																			//	Объявляем  массив     для хранения получаемых/передаваемых данных.
		iarduino_I2C_BASE*	objI2C;																				//	Объявляем  указатель  на  объект полиморфного класса iarduino_I2C_BASE, но в конструкторе данного класса этому указателю будет присвоена ссылка на производный класс iarduino_I2C.
	/**	Внутренние функции **/																					//
		bool				_readBytes			(uint8_t, uint8_t			);									//	Объявляем  функцию чтения данных в  массив  data								(Параметры: номер первого регистра, количество байт).
		bool				_writeBytes			(uint8_t, uint8_t, uint8_t=0);									//	Объявляем  функцию записи данных из массива data								(Параметры: номер первого регистра, количество байт, номер первого элемента массива data).
};																												//
																												//
#endif																											//